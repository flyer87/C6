//updateversion
//Code Contracts in the beginnig
=========
- invariants in C5
- RaiseForAddRange(array) - not correct
	- some of array items can't bo added, since they're already there. Should raise only for the added ones.
-     if (_underlying == null) or  if (_underlying == null) {
			return true; 				return true;
								   }
- insideview or Isinsideview
- methods with SCG.IEnumerable<T> items (ContainsRange, ...) some check in the beginnig of the method ?
- Improve GetUnsequencedHashCode() ???
- public static bool UnsequencedEquals<T>(this ICollection<T> first, ICollection<T> second, SCG.IEqualityComparer<T> equalityComparer = null)
	- Why ICollection, but no IEnumerable?
- isValid in privae classes like ItemSet, Duplicates, ...
- rename FindNodePrivate to FindNodeAndIndex ???
- General: set, insert of an extsing item in hashed version -> exception ?
- General: public void RemoveIndexRange(int startIndex, int count), Code contracts
	Requires(!IsEmpty) ???
- General: when ActiveEvents si really set to something
- ActiveEvents.HasFlag() passed for:
	- private void RaiseForIndexSetter(T oldItem, T item, int index), RaiseForRemove(T item, int count)
		Add a test
	
	
===========
Thesis notes:
	- void C5.AddNode() => bool C6.AddNode()
	- object initializer used in:
		private  void SplitTagGroupPrivate(TagGroup taggroup) {
			...
			var newtaggroup = new TagGroup { ... }
		}
		
	- private methods renamed:
		- contains => containsItem
	- LINQ for ContainsRange()
	- public static bool UnsequencedEquals<T>(this ICollection<T> first, ICollection<T> second, SCG.IEqualityComparer<T> equalityComparer = null)
		updated; C5 re-used. BUT DO WE NEED it?
		C6.4.3.6 Sequenced and Unsequenced Equality
			4.1.1 Order-Indifferent Equality
	- C5.HLL new Range()
		- field: endNode - needless