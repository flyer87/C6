//updateversion
//Code Contracts in the beginnig
=========
- try to get how the tag staff in the views work
- Double, triplle check C6.ArrayList with the view extension I did.
- check views - if all at their places?
- look at the test patterns of C6
- look at the C5's view tests
- write tests for the views
=========
- General: invariants from C5
- RaiseForAddRange(array) - not correct
	- some of array items can't bo added, since they're already there. Should raise only for the added ones.
-     if (_underlying == null) or  if (_underlying == null) {
			return true; 				return true;
								   }
- insideview or Isinsideview
- methods with SCG.IEnumerable<T> items (ContainsRange, ...) some check in the beginnig of the method ?
- Improve GetUnsequencedHashCode() ???
- public static bool UnsequencedEquals<T>(this ICollection<T> first, ICollection<T> second, SCG.IEqualityComparer<T> equalityComparer = null)
	- Why ICollection, but no IEnumerable?
- isValid in privae classes like ItemSet, Duplicates, ...
- General: set, insert of an extsing item in hashed version -> exception or ?
- General: public void RemoveIndexRange(int startIndex, int count), Code contracts
	Requires(!IsEmpty) ???
- General: when do we set ActiveEvents to something
- General: why SC. methods should be explicitly implemented
- ActiveEvents.HasFlag() passed for:
	- private void RaiseForIndexSetter(T oldItem, T item, int index), RaiseForRemove(T item, int count)
		Add a test
- General: CollectionExtensions - check for: // TODO: Test
- InsertNodeBeforePrivate()	should be used with FindOrAddToHash()
	if there is _itemNode.Contains BEFORE InsertNodeBeforePrivate(), replace it with FindOrAddToHash()
- Insert 
- General: Remove() methods: if Count <= 0 return false;
	
===========
Thesis notes:
	- void C5.AddNode() => bool C6.AddNode()
	- object initializer used in:
		private  void SplitTagGroupPrivate(TagGroup taggroup) {
			...
			var newtaggroup = new TagGroup { ... }
		}
		
	- private methods renamed:
		- contains => containsItem
	- LINQ for ContainsRange()
	- public static bool UnsequencedEquals<T>(this ICollection<T> first, ICollection<T> second, SCG.IEqualityComparer<T> equalityComparer = null)
		updated; C5 re-used. BUT DO WE NEED it?
		C6.4.3.6 Sequenced and Unsequenced Equality
			4.1.1 Order-Indifferent Equality
	- C5.HLL new Range()
		- field: endNode - needless
	- InsertRangePrivate:
		else C5.HLL: throw new DuplicateNotAllowedException("Item already in indexed list"); removed()
	- C5.Shuffle: count <= 0; now: C5.Shuffle: count <= 1
	- inconsistency: C6.Sort() accepts null for comparer; but Shuffle() doesn't accept Random as null
	- in Reverse:
		Sorting.IntroSort<Position>(positions, 0, positions.Length, PositionComparer.Default);
		change with Array.Sort()