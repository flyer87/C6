//updateversion
//Code Contracts in the beginnig
====
- General: invariants from C5
- Addrange() in the constructor with Code Contracts included, fails.
- RaiseForAddRange(array) - not correct
	- some of array items can't bo added, since they're already there. Should raise only for the added ones.
-     if (_underlying == null) or  if (_underlying == null) {
			return true; 				return true;
								   }
								   
- insideview or Isinsideview
- methods with SCG.IEnumerable<T> items (ContainsRange, ...) some check in the beginnig of the method ?
- Improve GetUnsequencedHashCode() ???
- public static bool UnsequencedEquals<T>(this ICollection<T> first, ICollection<T> second, SCG.IEqualityComparer<T> equalityComparer = null)
	- Why ICollection, but no IEnumerable?
- isValid in privae classes like ItemSet, Duplicates, ...
- General: set, insert of an extsing item in hashed version -> exception or ?
- General: public void RemoveIndexRange(int startIndex, int count), Code contracts
	Requires(!IsEmpty) ???
- General: when do we set ActiveEvents to something
- General: why SC. methods should be explicitly implemented
- ActiveEvents.HasFlag() passed for:
	- private void RaiseForIndexSetter(T oldItem, T item, int index), RaiseForRemove(T item, int count)
		Add a test
- General: CollectionExtensions - check for: // TODO: Test
- InsertNodeBeforePrivate()	should be used with FindOrAddToHash()
	if there is _itemNode.Contains BEFORE InsertNodeBeforePrivate(), replace it with FindOrAddToHash()
- Insert 
- General: Remove() methods: if Count <= 0 return false;
- General: methods getting SCG.IEnumerable<T>, f.ex. ContainsRange(SCG.IEnumerable<T> items)
	- should we call items.toArray() in the beginning of the method ?
- General: set doesn't have Code Contracts preconditions in its Interface hierarchy
===========
Thesis notes:
	- void C5.AddNode() => bool C6.AddNode()
	- object initializer used in:
		private  void SplitTagGroupPrivate(TagGroup taggroup) {
			...
			var newtaggroup = new TagGroup { ... }
		}
		
	- private methods renamed:
		- contains => containsItem
	- LINQ for ContainsRange()
	- public static bool UnsequencedEquals<T>(this ICollection<T> first, ICollection<T> second, SCG.IEqualityComparer<T> equalityComparer = null)
		updated; C5 re-used. BUT DO WE NEED it?
		C6.4.3.6 Sequenced and Unsequenced Equality
			4.1.1 Order-Indifferent Equality
	- C5.HLL new Range()
		- field: endNode - needless
	- InsertRangePrivate:
		else C5.HLL: throw new DuplicateNotAllowedException("Item already in indexed list"); removed()
	- C5.Shuffle: count <= 0; now: C5.Shuffle: count <= 1
	- inconsistency: C6.Sort() accepts null for comparer; but Shuffle() doesn't accept Random as null
	- in Reverse:
		Sorting.IntroSort<Position>(positions, 0, positions.Length, PositionComparer.Default);
		change with Array.Sort()
	- Tests, improvements: C6.ArrayList doesn't contain tests for thring an expcetion when 
AllowsDuplicate is false. Even if set AllowsDuplicate to false in ArrayList. Write test with AllowsDuplicate = true and expexted behvaior, which fails.
	- General: Code Contracts (which are implemented on inerface level) keeps us far from repeating the precondtions (in terms of check-throw-expcetion) in the concrete implementations.